#!/usr/bin/env python3
"""
Script to reverse engineer NIU firmware files
Generates disassembly for all .bin files that don't have .decompiled versions
"""

import os
import subprocess
import sys
from pathlib import Path

def find_firmware_files(base_dir):
    """Find all .bin files that don't have corresponding .decompiled files"""
    firmware_files = []
    
    for root, dirs, files in os.walk(base_dir):
        for file in files:
            if file.endswith('.bin'):
                bin_path = os.path.join(root, file)
                decompiled_path = bin_path + '.decompiled'
                
                # Only process if .decompiled doesn't exist
                if not os.path.exists(decompiled_path):
                    firmware_files.append(bin_path)
    
    return firmware_files

def disassemble_firmware(bin_path):
    """Disassemble firmware using ARM objdump"""
    print(f"Processing: {bin_path}")
    
    try:
        # Try ARM disassembly first
        cmd = [
            'arm-linux-gnueabi-objdump',
            '-b', 'binary',
            '-m', 'arm',
            '-D',
            bin_path
        ]
        
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        
        if result.returncode == 0:
            return result.stdout
        else:
            print(f"ARM disassembly failed for {bin_path}: {result.stderr}")
            
            # Fallback to x86 disassembly
            cmd_x86 = [
                'objdump',
                '-b', 'binary',
                '-m', 'i386',
                '-D',
                bin_path
            ]
            
            result_x86 = subprocess.run(cmd_x86, capture_output=True, text=True, timeout=60)
            
            if result_x86.returncode == 0:
                return result_x86.stdout
            else:
                print(f"x86 disassembly also failed for {bin_path}: {result_x86.stderr}")
                return None
                
    except subprocess.TimeoutExpired:
        print(f"Timeout occurred while processing {bin_path}")
        return None
    except Exception as e:
        print(f"Error processing {bin_path}: {e}")
        return None

def save_disassembly(bin_path, disassembly):
    """Save disassembly to .decompiled file"""
    output_path = bin_path + '.decompiled'
    
    try:
        with open(output_path, 'w') as f:
            f.write(f"// Disassembly of {os.path.basename(bin_path)}\n")
            f.write(f"// Generated by reverse_firmware.py\n")
            f.write(f"// Original file: {bin_path}\n\n")
            f.write(disassembly)
        
        print(f"Saved disassembly to: {output_path}")
        return True
    except Exception as e:
        print(f"Error saving disassembly to {output_path}: {e}")
        return False

def main():
    base_dir = os.path.dirname(os.path.abspath(__file__))
    
    print("NIU Firmware Reverse Engineering Tool")
    print("=====================================")
    
    # Find all firmware files to process
    firmware_files = find_firmware_files(base_dir)
    
    if not firmware_files:
        print("No firmware files found that need processing.")
        return
    
    print(f"Found {len(firmware_files)} firmware files to process:")
    for f in firmware_files:
        print(f"  - {f}")
    
    print("\nStarting reverse engineering process...")
    
    processed = 0
    failed = 0
    
    for bin_path in firmware_files:
        disassembly = disassemble_firmware(bin_path)
        
        if disassembly:
            if save_disassembly(bin_path, disassembly):
                processed += 1
            else:
                failed += 1
        else:
            failed += 1
    
    print(f"\nReverse engineering complete!")
    print(f"Successfully processed: {processed} files")
    print(f"Failed: {failed} files")

if __name__ == "__main__":
    main()